---
layout: post
title: "算法"
categories: 算法
tags: 算法 Algorithm
author: linkzw
---

* content
{:toc}

## 基础算法

* 经典常用的数据结构和典型算法（如二分查找，快速排序、Hash表）
* 一些高级数据结构（诸如红黑树、B树）
* 贪心、动态规划、图论
* 常用算法的时间复杂度。


基于各种数据结构上的增删改查。如字符串的查找翻转，链表的查找遍历合并删除，树和图的查找遍历后来为了更好的查找，我们想到了排序，排序仍然不够，我们有了贪心、动态规划，再后来东西多了，于是有了海量数据处理，资源有限导致人们彼此竞争，出现了博弈组合概率。


数组、栈、队列、循环队列、链表、树、二叉树、红黑树、AVL树、图、有向无环图、无向图、堆、散列表、集合、树状数组、

## 大数据处理

* 分而治之/hash映射 + hash统计 + 堆/快速/归并排序；
* 双层桶划分
* Bloom filter/Bitmap；
* Trie树/数据库/倒排索引；
* 外排序；
* 分布式处理之Hadoop/Mapreduce。


1.哈希分治；
2.simhash算法；
3.外排序；
4.MapReduce；
5.多层划分；
6.位图；
7.布隆过滤器；
8.Trie树；
9.数据库；
10.倒排索引。

关于项目，我出两个练手题目：

一、多机数据处理。有 10 台机器，每台机器上保存着 10 亿个 64-bit 整数（不一定刚好 10 亿个，可能有上下几千万的浮动），一共约 100 亿个整数（其实一共也就 80GB 数据，不算大，选这个量级是考虑了 VPS 虚拟机的容量，便于实验）。

编程求出：
	1. 这些数的平均数。
	2. 这些数的中位数。
	3. 出现次数最多的 100 万个数。
	*4. （附加题）对这 100 亿个整数排序，结果顺序存放到这 10 台机器上。
	*5. （附加健壮性要求）你的程序应该能正确应对输入数据的各种分布（均匀、正态、Zipf）。
	*6. （附加伸缩性要求）你的程序应该能平滑扩展到更多的机器，支持更大的数据量。比如 20 台机器、一共 200 亿个整数，或者 50 台机器、一共 500 亿个整数。
 
> 广搜是一层一层往外遍历，寻找最短路径，其策略是采取队列的方法。
最小生成树是最小代价连接所有点，其策略是贪心，比如Prim的策略是贪心+权重队列。
Dijkstra是寻找单源最短路径，其策略是贪心+非负权重队列。
Floyd是多结点对的最短路径，其策略是动态规划。


 ## 参考链接
 
[算法](https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/00.01.md)
[教你如何迅速秒杀掉：99%的海量数据处理面试题](https://blog.csdn.net/v_july_v/article/details/7382693)
[一些重要算法](https://coolshell.cn/articles/2583.html)

