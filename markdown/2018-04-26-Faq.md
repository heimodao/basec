---
layout: post
title: "名次解释"
categories: Faq
tags: faq
author: linkzw
---


* content
{:toc}

## [拓扑排序](https://songlee24.github.io/2015/05/07/topological-sorting/)

拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：

	1).每个顶点出现且只出现一次。
	2).若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。

有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。


写出拓扑排序常用的方法：

	1).从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。
	2).从图中删除该顶点和所有以它为起点的有向边。
	3).重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。

## 五种IO模型

模型			| 描述
----------------|-----------------------------------------
阻塞I/O模型		| 进程一直阻塞，直到数据拷贝完成
----------------|-----------------------------------------
非阻塞I/O模型	| 数据就绪之前一直轮询
----------------|-----------------------------------------
I/O复用模型		| 新增了一个系统调用select, 帮助进程监控多个I/O
----------------|-----------------------------------------
信号驱动I/O模型	| 进程通过接收到的信号确认数据准备就绪
----------------|-----------------------------------------
异步I/O			| 进程不受阻塞，将任务交给内核处理


* [Unix编程-五种IO模型](http://www.cnblogs.com/Lynn-Zhang/p/5711849.html)

* [码农有道-五种IO模型分析](https://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&mid=2247485371&idx=1&sn=35535cf5360a9993f169707f5adc0e0a&chksm=972ad6c1a05d5fd7638589b3c57b8c8f17539b2b17356ba1d1fd006ae7ac52615ab49ce13b97&mpshare=1&scene=1&srcid=0523wjC2LP3fZfboaLPD7VOH#rd)

* [select poll epoll区别](http://www.cnblogs.com/Anker/p/3265058.html)

## MapReduce

MapReduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。但如果你要我再通俗点介绍，那么，说白了，Mapreduce的原理就是一个归并排序。

适用范围：数据量大，但是数据种类小可以放入内存

基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。


## Hadoop

MapReduce是一种模式。
Hadoop是一种框架。
Hadoop是一个实现了MapReduce模式的开源的分布式并行编程框架。


## Spark

Apache Spark是一个开源集群运算框架，最初是由加州大学柏克莱分校AMPLab所开发。
相对于Hadoop的MapReduce会在运行完工作后将中介数据存放到磁盘中，Spark使用了存储器内运算技术，能在数据尚未写入硬盘时即在存储器内分析运算。
Spark在存储器内运行程序的运算速度能做到比Hadoop MapReduce的运算速度快上100倍，即便是运行程序于硬盘时，Spark也能快上10倍速度。
Spark允许用户将数据加载至集群存储器，并多次对其进行查询，非常适合用于机器学习算法。

## dubbo

Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring 框架无缝集成。

主要核心部件：

* Remoting: 网络通信框架，实现了 sync-over-async 和 request-response 消息机制

* RPC: 一个远程过程调用的抽象，支持负载均衡、容灾和集群功能

* Registry: 服务目录框架用于服务的注册和服务事件发布和订阅
		
## Trie树

Trie树，即字典树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。

Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

它有3个基本性质：

* 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
* 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
* 每个节点的所有子节点包含的字符都不相同。

## ProtoBuf

全称Google Protocol Buffer，是 Google 公司内部的混合语言数据标准，目前已经正在使用的有超过 48,162 种报文格式定义和超过 12,183 个 .proto 文件。他们用于 RPC 系统和持续数据存储系统。

Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。


## 创建者/消费者模型

生产者消费者问题（英语：Producer-consumer problem）,也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。

	该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。
	生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。
	该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。

解决方法:

	要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。
	同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。
	通常采用进程间通信的方法解决该问题，常用的方法有信号灯法等。
	如果解决方法不够完善，则容易出现活锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形。

## 正则匹配

> https://c.runoob.com/front-end/854

	^(?!commit_by_shell).*$		<=> 过滤掉commit_by_shell
	(baidu|ali|tencent)			<=> 匹配baidu、ali、tencent

## Lua5.3


> [目录](http://cloudwu.github.io/lua53doc/contents.html)


> [内容](http://cloudwu.github.io/lua53doc/manual.html)


## lua语法静态检查
	
	luacheck
	sudo apt-get install luarocks
	luarocks install luacheck
	luacheck --config .luacheckrc ../src/gamelogic/* > /tmp/luacheck.log
	luacheck /home/nomogaserver/gamesrv_3/src/gamelogic/* > /tmp/luacheck.log

## 动态规划、贪婪算法、NP完全

贪婪算法：解决最优化的问题。

因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。

	1. 建立数学模型来描述问题。
	2. 把求解的问题分成若干个子问题。
	3. 对每一子问题求解，得到子问题的局部最优解。
	4. 把子问题的解局部最优解合成原来解问题的一个解。

对于大部分的问题，贪心法通常都不能找出最佳解（不过也有例外），因为他们一般没有测试所有可能的解。贪心法容易过早做决定，因而没法达到最佳解。例如，所有对图着色问题。
贪心法在系统故障诊断策略生成乃至高校的排课系统中都可使用。


动态规划(Dynamic programming，简称DP)：

	通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
	动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。
	动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。
	为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。

	动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。
	

## telnet退出

	ctrl + ]
	quit
	
## ls显示

	只显示文件夹 		ls -l | grep ^d
	只显示文件 			ls -l | grep ^-
	文件是以 "-"开头 ， 文件夹是 d， 所以这就是后面grep的内容。
	

## 密钥

生成密钥

	ssh-keygen -t rsa -f filename -C email@email.com
	-f:生成名称 生成filename filename.pub
	-C:用户邮箱

远程连接免密登录

	ssh-copy-id user@host

## 查看ubuntu所有用户

	cat /etc/passwd |cut -f 1 -d :

## 阿里云邮箱

* 收件服务器地址：

	POP 服务器地址：pop3.mxhichina.com 端口110，SSL 加密端口995

	IMAP 服务器地址：imap.mxhichina.com 端口143，SSL 加密端口993

* 发件服务器地址：

	SMTP 服务器地址：smtp.mxhichina.com 端口25， SSL 加密端口465

## 域名解析

* 查看域名解析记录
	
	ubuntu:dig mx linkzw.com

* 域名解析

	www：用以精确匹配www开头的域名，如www.linkzw.com，不能匹配linkzw.com

	@：可以匹配直接访问linkzw.com的情况

	/*：泛域名，可匹配任意域名，如linkzw.abc.com, www.linkzw.com，linkzw.com


## CPU

CPU擅长逻辑控制，串行的运算。和通用类型数据运算不同，GPU擅长的是大规模并发计算，这正是密码破解等所需要的。所以GPU除了图像处理，也越来越多的参与到计算当中来。


## [以太网帧格式](https://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&mid=2247483761&idx=1&sn=4073ddf075b22348e73411d96318f49c&chksm=972ad00ba05d591d0eb92f87bc7727d65d0d5de75a67cd1c272e5af2abe88359315dd218cee1&mpshare=1&scene=21&srcid=1007KuqnmRcOfeN1Zk3MtLW9#wechat_redirect)

	Preamble 	SFD 	DST 	SRC 	Type 	Payload(Data) 	Pad 	FCS 	Extension

* 序言(preamble):

序言是为了让接收设备调整接收频率，以便与发送设备的频率一致 7个byte,它每个byte都是0xAA(这里是十六进制，也就是二进制的10101010)

* 始信号(SFD, start frame delimiter)

SFD是固定的值0xAB
SFD之后是6 byte的目的地址(DST, destination)和6 byte的源地址(SRC,source)

MAC地址是物理设备自带的序号，只能在同一个以太网中被识别 

* Type

用以说明数据部分的类型。(比如0x0800为IPv4，0x0806为ARP)

* 数据

Payload(Data)数据尾部可能填充有一串0(PAD区域) 

原因是数据需要超过一定的最小长度，不同的协议要求的数据最小长度是不一样的，例如：以太网(IEEE 802.3)要求帧的数据部分长度是46-1500个byte。如果数据部分不够46byte，则在数据尾部填充0以达到指定的最小长度。


* 校验序列(FCS, Frame Check Sequence)

为了检验数据的传输是否发生错误，FCS采用了CRC(Cyclic Redundancy Check)算法

> ARP协议只用于IPv4。IPv6使用Neighbor Discovery Protocol来替代ARP的功能)

## vim替换

	:s/foo/bar/g 		<=> 将当前行的foo替换成bar
	:%s/foo/bar/g 		<=> 将当前文件的foo替换成bar
	:5,12s/foo/bar/g 	<=> 将5~12行的foo替换成bar
	:.,+2s/foo/bar/g 	<=> 将当前行以及后两行的foo替换成bar


## 查询函数调用

	grep -nr function.*test **/*.lua
	:vim /function.*test/ **/*.lua 		<=> vim中查找当前递归目录下定义test函数的地方

## 字符串处理

	grep、awk、sed三剑客，grep负责找出特定的行，awk能将行拆分成多个字段，sed则可以实现更新插入删除等写操作。
	
	
## 字典的实现
	
最简单的就是使用链表或数组，但是这种方式只适用于元素个数不多的情况下；
要兼顾高效和简单性，可以使用哈希表；
如果追求更为稳定的性能特征，并希望高效地实现排序操作的话，则可使用更为复杂的平衡树；


## define  _CRT_SECURE_NO_WARNINGS 

在编译老的用C语言的开源项目如lua源包的时候，可能因为一些老的.c文件使用了strcpy,scanf等不安全的函数，而报警告和错误，而导致无法编译通过。
